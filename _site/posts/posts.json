[
  {
    "path": "posts/2020-11-25 R Source Code for Bond Analysis/",
    "title": "R Source Code for Bond Analysis",
    "description": "This is a highly accurate bond yield and analytics calculator. I would love to unoficially claim this to be the most accurate bond calculator found on the internet, including public R and Python packages, but not until I have completed a few enhancements first.",
    "author": [
      {
        "name": "Chen Xihui",
        "url": {}
      }
    ],
    "date": "2020-11-25",
    "categories": [
      "Bonds"
    ],
    "contents": "\nThis code calculates a bond’s yield to maturity, macaulay duration, modified duration, convexity, accrued interest, price, payment dates and amortised (scientific) book value at any point in time. The accuracy here is not because it uses the commonly-used Newton-Raphson iteration method to derive the internal rate of return but it takes into account the holiday schedules, business day and day count conventions according to ICMA definition and using the bond-appropriate fractional and compounding methods, all without using any mathematical shortcuts. By changing the variables, you can, in most cases clone the results of other investment analytics software.\nI am sharing this code temporarily in the hope that I can collaborate with developers to enhance a few other features, namely, to handle complex fixed income instruments, expand the number of day count methods and allow the computation of large bond holdings for portfolio analysis (Java OOP may be ideal for such environment). Minor enhancements are call to yield, zero-coupon and irregular dated date, etc.\nYou may be wondering, these are standard features found in data providers and portfolio management systems. The answer is not really. Some use shortcuts by omitting certain parameters and some make assumptions about the coupon payment date and amount, or employ different methodologies. So far, I have found, at least for ACT/ACT, only Eagle Investment System produced the same output, tested for up to 19 decimal places.\nAnother question is, why the need for such accuracy? Because of the complexity in calculating a bond’s true yield, the market has generally accepted the street convention yield, which is why Bloomberg (they have true yield too) and Excel values have become the standard in the market. However, dozens of the most popular treasury and portfolio systems would still give you different numbers but for practical purposes, especially as a fund manager, any value beyond 3 decimal places is insignificant. For fund accounting, it may serve a better purpose to have higher level of precision as discrepancy in gains/losses can be more obvious for large holdings. It is also useful in audit and implementation proof of concept to assure all parties understand why different values are observed from different sources.\nAgain, this code is not all about yield. It generates the correct actual coupon payment dates and amount which some systems don’t. For example, a bond’s coupon payment date falls on a weekend. If it is set to pay the amount up to that accrual date, then yield has to be calculate based on that date. However, the system needs to show the different accrual end date and the actual payment date.\nSo here’s the roughly 300 lines of back-end code. Sorry, functions (or shall I say, the code that runs the main engine) will not be shown, although eventually I would like this to be an open-source portfolio analytics program that can be used by all investment managers.\n\n\n# ===== LOAD PACKAGES =====\n\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(readxl)\n\n\n# ===== IMPORT DATA =====\n\nholidays <- read_excel(\"~/Documents/R-Amortisation/Holidays.xlsx\")\n\n\n# ===== INPUT PARAMETERS =====\n\n# Remove these parameters eventually. Enter values directly in the function arguments.\n\ncalendar <- \"US\"\nissue_date <- as.Date('2017-01-25') # Rule - Must be less than maturity date\nend_of_month <- 0 # 1 = Yes, 0 = No\nmaturity_date <- as.Date('2022-07-20')\nsettle_date <- as.Date('2020-12-15') # Rule - 1. Cannot be less than issue date 2. Display reactive years to maturity\nreport_date <- as.Date('2021-02-28') # Rule - 1. Report date must be greater than settle date (change to value_date)\n\npar_value <- 1000 # Rule: Either principal OR yield must be populated. If both are populated, then yield will be re-calculated.\nprincipal <- 1048.29 # Rule: Warning if +/- 50% of par value\nyield <- 0.04# 0.0585996480227246\ncoupon_rate <- 0.0758\n\npay_freq <- 2   # Annual (1), Semi-annual (2), Quarterly (4), Monthly (12)\nbus_day <- 1    # No Adjustment (1), Following BD (2), Modified Following (3), Previous BD (4), Modified Previous BD (5)\nday_count <- 1  # ACT/365 Fixed ICMA (1), ACT/365L (2),  ACT/ACT ICMA (3), 30E/360 (4), 30/360 US (5), ACT/360 (6)\n\ncall_date <- as.Date('2005-02-02') # Rule - must be less than maturity date \ncall_price # call redemption amount/price (usually at premium)\n\n\n# ===== MAIN FUNCTION ======\n\nbond.schedule <- function(par, prin = NULL, yld = NULL, rate, settle, issue = NULL, maturity, call = NULL, freq, eom, bdc, dcm, cal = \"MY\") {\n  \n  # ===== PROCESS =====\n  \n  # 1 --- CREATE INITIAL SCHEDULE OF COUPON PAYMENT DATES ---\n  \n  # Dates are non-adjusted and based on whether issue date or maturity date has been provided.\n  # Date range is from last coupon date prior to settlement up to maturity date.\n\n  if (is.null(issue)) {issue_no(settle, maturity, freq, eom)} else {issue_yes(settle, issue, maturity, freq, eom)}\n  \n  \n  # 2 --- ADJUST DATES (BUSINESS DAY CONVENTION) ---\n  \n  # Adjust dates according to business day convention and holidays. Add transaction types and date-related information.\n  \n   schedule <<- schedule %>%\n     \n    mutate(DueDate = case_when(bdc == 1 ~ coupon_dates, bdc == 2 ~ foll_bd(cal), bdc == 3 ~ mod_foll_bd(cal),\n                               bdc == 4 ~ prev_bd(cal), bdc == 5 ~ mod_prev_bd(cal)),\n           Type = case_when(DueDate %in% c(settle,issue) ~ \"Issue\", TRUE ~ \"Coupon\")) %>%\n     \n    add_row(DueDate = settle, Type = \"Settle\") %>%\n    add_row(DueDate = maturity, Type = \"Redemption\") %>%\n     \n    arrange(DueDate, Type) %>%\n\n    mutate(DueDate = replace(DueDate, Type == \"Coupon\" & DueDate == max(DueDate), as.Date(maturity)), # adjust last coupon date to match maturity date\n           Day = weekdays(DueDate, abbreviate(TRUE)),\n           PriorDueDate = case_when(Type == \"Settle\" ~ lag(DueDate),\n                                    Type %in% c(\"Issue\", \"Redemption\") ~ DueDate,\n                                    TRUE ~ lag(DueDate, default = DueDate[1], order_by = Type)),\n           ParValue = par,\n           CouponYN = case_when(Type == \"Coupon\" & DueDate > settle ~ 1, TRUE ~ 0),\n           CouponNo = cumsum(CouponYN)) %>%\n  \n     arrange(DueDate, Type) # arrange again in case maturity date is less than last coupon date prior to date adjustment\n\n   \n  # 3 --- CALCULATE ACCRUAL DAYS, AMOUNT AND TIME FACTOR (DAY COUNT METHOD) ---\n   \n  if (dcm == 1) {act_365(par, rate, dcm)} else\n    if (dcm == 2) {act_365L(par, rate, dcm)} else\n      if (dcm == 3) {act_act(par, rate, freq, dcm)} else\n        if (dcm == 6) {act_360(par, rate, dcm)} else\n          if (dcm %in% c(4,5)) {thirty_days(dcm, freq, par, rate)}\n \n   \n  # 4 --- SET VARIABLES ---\n   \n   # Purchase Accrued Interest\n   AccruedInterest <- abs(with(schedule, Amount[Type == \"Settle\"]))\n   \n   # Dirty price - principal plus purchase accrued interest\n   PurchaseAmount <- if (is.null(prin) == TRUE) 0 else prin + AccruedInterest\n   \n   # Total cash flow at maturity\n   FinalAmount <- with(schedule, Amount[Type == \"Coupon\" & DueDate == max(DueDate)]) + par\n   \n   # Number of days in the final coupon period\n   FinalPeriodDays <- with(schedule, AccrualDays[Type == \"Coupon\" & DueDate == max(DueDate)])\n   \n   # Number of coupon payments after settle date\n   CpnPayments <- length(which(with(schedule, Type == \"Coupon\" & DueDate > DueDate[Type == \"Settle\"])))\n   \n   # Standard present value formula\n   pv_multiple_cpn <- quote(sum(with(schedule, Amount / (1 + Yld / freq) ^ n)))\n   \n   # Present value formula used by Excel if settle date fall within the last coupon period\n   pv_final_cpn <- quote(with(schedule, sum(Amount[DueDate == max(DueDate)]) /\n                                (1 + Yld * Fraction[Type == \"Coupon\" & DueDate >= DueDate[Type==\"Settle\"]] / freq) - AccruedInterest))\n   \n   \n  # 5 --- YIELD AND PRICE ---\n   \n  # Scenario 1: Calculate Yield. Price is given. Yield is re-calculated whether a value exists or is null.\n   \n   if (is.null(prin) == FALSE) { # originally included condition & is.null(yld) == TRUE but removed to let existing yield input to be over-ridden.\n     \n  # Different formula is applied if settle date falls on final coupon period.\n     \n     if (CpnPayments == 1) {\n       \n       Yld <<- (FinalAmount / PurchaseAmount - 1) / (with(schedule, Fraction[Type == \"Coupon\" & DueDate >= DueDate[Type==\"Settle\"]])/freq)\n       PresentValue <- eval(pv_final_cpn)\n       Prin <- prin\n       \n       } else\n         \n         if (CpnPayments > 1) {\n           pv <- function(r) {\n           sum(with(schedule, Amount / (1 + r) ^ n)) - prin}\n           Yld <<- uniroot(pv, lower = 0, upper = 0.1, extendInt = \"yes\", tol = .Machine$double.xmin, maxiter = 10000)[[1]] * freq\n           PresentValue <- eval(pv_multiple_cpn)\n           Prin <- prin\n           }\n     \n   # Scenario 2: Calculate Principal. User only provide Yield.\n     \n     ## ACTION --- this part may need to add CpnPayments conditions like the above?\n   } else\n    \n      if (is.null(prin) == TRUE & is.null(yld) == FALSE) {\n        Yld <<- yld\n        \n        if (CpnPayments == 1) {\n        PresentValue <- eval(pv_final_cpn)\n        \n        } else\n          \n          if (CpnPayments > 1) {\n            PresentValue <- eval(pv_multiple_cpn)\n          }\n        \n        Prin <- PresentValue\n        PurchaseAmount <- PresentValue + AccruedInterest\n        }\n   \n   \n   # 6 --- PERIODIC BOOK VALUE ---\n\n   schedule <<- schedule %>%\n    \n    mutate(BookValue = book(),\n           Amortised = case_when(BookValue == 0 ~ 0, TRUE ~ Prin - BookValue),\n           \n           \n           # 7 --- ANALYTICS ---\n           \n           pv1 = sum(Amount / (1 + (Yld - 0.01) / freq) ^ n),\n           pv2 = sum(Amount / (1 + (Yld + 0.01) / freq) ^ n),\n           yldDec = (pv1 - Prin) / Prin * 100,\n           yldInc = (pv2 - Prin) / Prin * 100,\n           effDur = (pv1 - pv2) / (2 * Prin * 0.01),\n           \n           # Duration - present value does not include purchase accrued interest.\n           pvEx = case_when(Type == \"Settle\" ~ 0, TRUE ~ Amount / (1 + Yld / freq) ^ n),\n           macDur = (sum(pvEx * n) / sum(pvEx)) / freq,\n           modDur = macDur / (1 + Yld / freq),\n           \n           convex = sum(pvEx / sum(pvEx) * (n ^ 2 + n) / (1 + Yld / freq) ^ 2) / (freq ^ 2),\n           effConvex = (pv1 + pv2 - 2 * Prin) / (Prin * 0.01 ^ 2), # Using convexity approximation formula with delta 0.01 (100bp or 1%)\n           \n           dv01 = Prin * modDur * 0.0001 + 0.5 * convex * 100 * 0.0001 ^ 2, # effect of decline in absolute price due to increase in yield by 0.01%\n           dv01dir = -(sum(Amount/(1 + (Yld + 0.0001) / freq) ^ n) - Prin)) # direct method\n  \n           \n  # 8 --- SUMMARY ---\n  \n  analytics <- data.frame(output = \n    \n    c(\n      schedule$AccrualDays[schedule$Type == \"Settle\"],\n      format(AccruedInterest, nsmall = 2, big.mark = \",\"),\n      format(PurchaseAmount, nsmall = 2, big.mark = \",\"),\n      format(Yld * 100, nsmall = 12),\n      format(Prin, nsmall = 2, big.mark = \",\"),\n      format(PresentValue, nsmall = 8, big.mark = \",\"),\n      format(max(schedule$effDur), nsmall = 8), # not sure if this is correct. Could be correct for mod duration approximation but not for call option.\n      paste0(format(max(schedule$pv2), nsmall = 2, big.mark = \",\"), \" (\", format(max(schedule$yldInc), nsmall = 6, digits = 0), \"%)\"),\n      paste0(format(max(schedule$pv1), nsmall = 2, big.mark = \",\"), \" (+\", format(max(schedule$yldDec), nsmall = 6, digits = 0), \"%)\"),\n      format(max(schedule$macDur), nsmall = 10), # tested and confirmed to be correct and consistent with Excel\n      format(max(schedule$modDur), nsmall = 10), # tested and confirmed to be correct and consistent with Excel\n      max(schedule$convex), # seems correct but have not tested for monthly, quarterly and annual coupon\n      max(schedule$effConvex),\n      max(schedule$dv01), # not so correct, it seems\n      max(schedule$dv01dir),\n      1,1,1,1,1,1,1,1,1,1,1,1,1,1))\n  \n  row.names(analytics) <- \n    c(\"Days_Accrued\",\n    \"AccruedInterest\",\n    \"Purchase_Amount\",\n    \"Yield\",\n    \"Principal\",\n    \"Present_Value\",\n    \"Effective_Duration\",\n    \"Yield_Increase_100_bp\",\n    \"Yield_Decrease_100_bp\",\n    \"Macaulay_Duration\",\n    \"Modified_Duration\",\n    \"Convexity\",\n    \"Effective_Convexity\",\n    \"DV01\",\n    \"DV01_DirectMethod\",\n    \"From CBonds:\",\n    \"Nominal Yield\",\n    \"Effective Yield\",\n    \"Current Yield\",\n    \"Adjusted Current Yield\",\n    \"G-Spread\", \"T-Spread\", \"Z-Spread\",\n    \"True Yield\", \"Street Convention\",\n    \"Holding Period Yield\",\n    \"Bond Equivalent Yield\", \"EAY (Effective Annual Yield?)\", \"Discount Yield\"\n    )\n  \n  analytics\n  \n} # End of Main Function\n\nbond.schedule(par = par_value,\n              prin = principal,\n              yld = ,\n              rate = coupon_rate,\n              settle = settle_date,\n              issue = ,\n              maturity = maturity_date,\n              call = ,\n              freq = pay_freq,\n              eom = end_of_month,\n              bdc = bus_day,\n              dcm = day_count,\n              cal = calendar)\n\n\nView(schedule)\n\nrm(schedule)\nrm(bond.schedule)\nrm(Yld)\n\n\n# ===== BOOK VALUE CALCULATOR =====\n\n# 1. Reporting date = R. Find the coupon date C that is paid prior to R.\n# 2. Calculate the number of accrued days D = C - R. Then calculate fraction f = D / P where P = no. of days in that period.\n# 3. Book Value on R = BV on C * (1 + r/freq)^f - D/P * Coupon amount in that period. First period calculation from settle is\n# different due to accrued interest. Final coupon period does not change like Excel where it assumes settle in last period is \n# zero coupon with add-on like money market formula for discount factor.\n\n# From each row in the monthly dates created above, find the book value.\n\nbv_calc <- function(rpt) {\n  \n  # Create a monthly vector from settle date to maturity date, and add settle, maturity and report dates\n  \n  months_to_maturity <- interval(settle_date, maturity_date) %/% months(1)\n  monthly_bv <- ceiling_date(settle_date %m+% months(0:months_to_maturity), \"month\") %m-% days(1)\n  monthly_bv[c(length(monthly_bv) + 1, length(monthly_bv) + 2, length(monthly_bv) + 3)] = c(settle_date, maturity_date, rpt)\n  monthly_bv <- sort(monthly_bv, decreasing = FALSE)\n  \n  # Function to calculate the accrual days for 30/360 Day Count Methods\n  \n  thirty360 <- function() {\n    Y1 <-  as.numeric(format(PriorDate,'%Y'))\n    Y2 <-  as.numeric(format(MonthEndDates,'%Y'))\n    M1 <-  as.numeric(format(PriorDate,'%m'))\n    M2 <-  as.numeric(format(MonthEndDates,'%m'))\n    D1 <-  case_when(day_count %in% c(4,5) & format(PriorDate,'%d') == \"31\" ~ 30, # If @d1 is 31, set @d1 to 30 for both day_count\n                     day_count == 5 & M1 == 2 & format(PriorDate+1, '%d') == \"01\" ~ 30, # If the start date is on the last day of Feb, set @d1 to 30.\n                     TRUE ~ as.numeric(format(PriorDate,'%d')))\n    D2 <-  case_when(day_count == 4 & format(MonthEndDates,'%d') == \"31\" ~ 30,\n                     day_count == 5 & M1 == 2 & format(PriorDate + 1, '%d') == \"01\" & M2 == 2 &\n                       format(MonthEndDates+1, '%d') == \"01\" ~ 30, # If both from and to dates are last day of Feb, set @d2 to 30\n                     day_count == 5 & format(PriorDate,'%d') >= \"30\" & format(MonthEndDates,'%d') > \"30\" ~ 30, # If @d1 is 30 or 31 and @d2 is 31, set @d2 to 30\n                     TRUE ~ as.numeric(format(MonthEndDates, '%d')))\n    AccDays <-  360*(Y2-Y1)+30*(M2-M1)+(D2-D1)\n  }\n  \n  # Create a vector of book values for each of the dates in monthly_bv\n  \n  bookvalueR <- vector(mode=\"numeric\", length = length(monthly_bv))\n  \n  for(j in seq_along(monthly_bv)) {\n    \n    MonthEndDates <- as.Date(monthly_bv[j])\n    DateDiff <- MonthEndDates-schedule$DueDate\n    minDateDiff <- min(DateDiff[DateDiff >= 0])\n    CodeStr <- quote(DateDiff == minDateDiff & schedule$Type != \"Redemption\")\n    PriorDate <- schedule$DueDate[eval(CodeStr)]\n    PriorDateBV <- schedule$BookValue[eval(CodeStr)]\n    DaysinPeriod <- schedule$AccrualDays[which(eval(CodeStr)) + 1]\n    AmountinPeriod <- schedule$Amount[which(eval(CodeStr)) + 1]\n    FirstCpn <- schedule$DueDate[which(schedule$Type == \"Settle\") + 1] # risk: assumes that Coupon are always followed by Settle, otherwise set first coupon is CouponNo==1\n    f <- if (day_count %in% c(4,5)) {thirty360() / DaysinPeriod} else as.numeric(minDateDiff / DaysinPeriod)\n    \n    bookvalueR[j] = if (MonthEndDates >= FirstCpn) {format(PriorDateBV*(1 + Yld / pay_freq) ^ f - f * AmountinPeriod, nsmall = 2)} else\n      if (MonthEndDates < FirstCpn) {format((PriorDateBV - schedule$Amount[schedule$Type == \"Settle\"]) * (1 + Yld / pay_freq) ^ f\n                                          - f*AmountinPeriod+schedule$Amount[schedule$Type == \"Settle\"], nsmall = 2)}\n    bookvalueR[length(monthly_bv)] = par_value\n  }\n  monthly_bv <<- data.frame(monthly_bv, bookvalueR) # combine both vectors in a data frame\n  }\n\nbv_calc(report_date)\n\nView(monthly_bv)\n\nrm(monthly_bv)\n\n\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-02-05T14:04:56+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-06-30 Bond Amortisation Constant Yield Method/",
    "title": "Bond Amortisation Constant Yield Method",
    "description": "Designing bond amortisation reports - using formulas instead of schedules.",
    "author": [
      {
        "name": "Chen Xihui",
        "url": {}
      }
    ],
    "date": "2020-06-30",
    "categories": [
      "Bonds"
    ],
    "contents": "\nAlso known as effective or scientific amortisation, this method uses constant yield to calculate the amount to gradually decrease (or increase) the book value of a bond down (or up) to its face value. The time period is usually taken from settlement date of purchase to maturity date, or sometimes the call date.\n\nBond Amortisation Schedule\nIf you understand how loan amortisation schedule works, we can easily relate this to bond amortisation. If we buy a bond at a premium, we need to amortise it over time to reach its par value at maturity. Bond and loan amortisation schedules are very similar – realise that loans are already amortised using the constant yield method. In setting up a bond amortisation schedule, think of it as an amortising loan with balloon payment, which means that you, as a lender, receive a lump sum on maturity date.\nThe main objective of these schedules is to show the principal balance as they are deducted from periodic payments. The table below shows the general differences when setting up a typical fixed rate loan or bond schedule.\nVariable\nLoans\nBonds\nPresent Value\nInitial Loan Amount\nBook cost\nEnding/Future Value\nAmortised to $0\nAmortised to par value\nInterest Expense\nLoan Interest Rate\nYield to Maturity/Call\nPeriodic Payment\nInstalment (Principal & Interest)\nCoupon\nPayment Frequency\nMonthly\nQuarterly, Semi-annual, Annual\nTo setup a bond amortisation schedule, determine:\nThe beginning value and ending value.\nInterest Expense. Excel’s Yield function is commonly used to calculate the bond’s yield to maturity. The coupon less this interest expense is the amortisation value that reduces the book value of the bond.\nThe constant periodic payment. This always consists of principal and interest portion. If the entire payment is made up of interest only, this only means that Yield=Coupon Rate and therefore there is no need to amortise as the bond is likely priced at par. For loans, we use PMT function to derive the constant P&I payment, but for bonds we just use the coupon amount. Some people might be confused into thinking that coupon rate is the interest rate used in the calculation of the bond amortisation schedule. It is not. Think of the coupon amount as equivalent to the PMT value that is required to pay for both interest and principal.\nPayment Frequency. It is not necessary to build a bond schedule according to the payment period. Most bonds pay semi-annually but you may want a monthly valuation for reporting purposes so your schedule needs to be expanded into ‘sub-periods’. In this case, the coupon amount needs to be apportioned according to the frequency or numbers of days in the accrual period.\n\nDaily Amortisation Schedule If you are seeking fairly accurate values at every month or even daily, you might want to create a daily schedule. The most common method is to find the daily yield using the goal seek function or simply using the Yield function and divide by 365. Both will give slightly different results but differences are marginal.\nMaintaining schedules cause efficiency problems. A bond that matures in 20 years will require you to have more than 7,300 rows in the schedule. Imagine having a hundred specific lots in your portfolio and each complete schedule is maintained in separate Excel sheets. That’s a lot to process, especially when it is time to aggregate the numbers during the reporting period. Not forgetting that goal seek can make you wait for a long time. Most likely you have an investment system that do all the work, but one of the most common issues (especially with internal auditors) arising from this method of amortisation is the fact that numbers hardly ever reconcile. This unfortunately leads to manual checks by comparing the schedules in Excel against the investment system.\nOne way to resolve most parts of this issue is to:\nGet rid of all the schedules and use the FV or PV functions in Excel. With this, you only need to maintain a single sheet containing all the bond holdings. The consolidation allows all kinds of aggregation to be performed for any date. FV and PV functions give the exact same result as goal seek because the daily coupon values are the same. Note that the balance or the amortised value is basically the future value of all net cash flow (negative principal outlay and positive coupon) up to the reporting, or to work backwards, the present value of redemption principal and coupons from reporting date to maturity date.\nTo make comparisons with systems, you may want to add a second method:\nUse the Yield method in Excel to find the price (to give book value) as at a specified date, given the coupon rate (unlike FV or PV functions which requires nominal amount). This method works more closely with system algorithms. However, you may realise that using yield to compute exhibits a scalloping effect which cause the difference amount to go up and down along the periods. You may also find the opposite effect where, for example, the discount bond amortises then does an accretion.\nEven after you have looked at several methodologies, there will always be differences. None are more accurate than the other, it really depends on the assumptions which is important for the asset managers to note and adopt into their policies and guidelines so they can set a tolerance level. For example, FV and PV methods share the same variables and it assumes daily interest throughout the period with constant daily coupon based on 365 days. Other algorithms may only calculate actual coupon amount and rates based on payment frequency except when the reporting date falls within the accrual period.\nContact me if you need help in implementing amortisation reports and policies. For optimum performance, target the use of reporting tools, SQL and programming languages such as R and Python, instead of Excel.\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-02-03T23:51:44+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-06-30 Bond Amortisation Examples with R/",
    "title": "Bond Amortisation Examples with R",
    "description": "Build a bond amortisation schedule with R",
    "author": [
      {
        "name": "Chen Xihui",
        "url": {}
      }
    ],
    "date": "2020-06-30",
    "categories": [
      "Bonds"
    ],
    "contents": "\nInitial Data\nThe data frame contains sample holdings data for 20 bonds. Lets assume all the bonds pays coupon semi-annually and accrual basis is ACT/365.\n\n\n(#tab:Amortisation Example)Bond Holdings as at 30-Sep-2009\n\n\nBond\n\n\nParValue\n\n\nPrincipal\n\n\nSettleDate\n\n\nMaturityDate\n\n\nCouponRate\n\n\nA\n\n\n5,000,000\n\n\n5,026,500\n\n\n2006-11-23\n\n\n2010-04-13\n\n\n0.039\n\n\nB\n\n\n50,000,000\n\n\n50,010,500\n\n\n2008-02-29\n\n\n2011-09-28\n\n\n0.036\n\n\nC\n\n\n20,000,000\n\n\n20,016,000\n\n\n2005-11-23\n\n\n2011-04-28\n\n\n0.038\n\n\nD\n\n\n5,000,000\n\n\n4,995,000\n\n\n2005-11-25\n\n\n2011-04-28\n\n\n0.038\n\n\nE\n\n\n25,000,000\n\n\n25,330,750\n\n\n2008-03-04\n\n\n2011-09-28\n\n\n0.038\n\n\nF\n\n\n25,000,000\n\n\n24,862,500\n\n\n2007-08-21\n\n\n2013-02-25\n\n\n0.037\n\n\nG\n\n\n40,000,000\n\n\n39,260,000\n\n\n2008-06-12\n\n\n2013-02-25\n\n\n0.037\n\n\nH\n\n\n10,000,000\n\n\n9,815,000\n\n\n2008-06-12\n\n\n2013-02-25\n\n\n0.037\n\n\nI\n\n\n50,000,000\n\n\n49,942,000\n\n\n2006-09-15\n\n\n2026-09-15\n\n\n0.047\n\n\nJ\n\n\n30,000,000\n\n\n30,060,000\n\n\n2006-09-21\n\n\n2026-09-15\n\n\n0.047\n\n\nK\n\n\n5,000,000\n\n\n5,140,250\n\n\n2006-10-03\n\n\n2026-09-15\n\n\n0.047\n\n\nL\n\n\n15,000,000\n\n\n15,421,500\n\n\n2006-10-03\n\n\n2026-09-15\n\n\n0.047\n\n\nM\n\n\n10,000,000\n\n\n10,261,000\n\n\n2006-10-04\n\n\n2026-09-15\n\n\n0.047\n\n\nO\n\n\n30,000,000\n\n\n28,008,000\n\n\n2007-07-23\n\n\n2027-05-31\n\n\n0.035\n\n\nN\n\n\n50,000,000\n\n\n46,285,000\n\n\n2007-07-31\n\n\n2027-05-31\n\n\n0.035\n\n\nP\n\n\n30,000,000\n\n\n27,666,000\n\n\n2007-08-10\n\n\n2027-05-31\n\n\n0.035\n\n\nQ\n\n\n15,000,000\n\n\n13,824,000\n\n\n2007-08-10\n\n\n2027-05-31\n\n\n0.035\n\n\nR\n\n\n20,000,000\n\n\n18,414,000\n\n\n2007-08-14\n\n\n2027-05-31\n\n\n0.035\n\n\nS\n\n\n12,000,000\n\n\n13,236,000\n\n\n2007-01-26\n\n\n2025-07-15\n\n\n0.048\n\n\nT\n\n\n15,000,000\n\n\n15,210,000\n\n\n2009-06-10\n\n\n2019-11-29\n\n\n0.044\n\n\n\nCalculate Using Excel’s FV, PV and PRICE Functions\nFV and PV methods produce the same results since they share some common variables and assumptions, such as assuming daily cash flow throughout the amortisation period. Price method is based on the YIELD and PRICE functions and follow day count conventions and hence, more reflective of actual cash flow.\nYIELD Function (Source: Excel Help File)\n\nComparing Amortised Book Values of Bonds\nObserve that the differences are relatively small between Price Method and the PV/FV methods. \n\nAssign Variables and Create Columns\nNow, we will show how to create a simple bond amortisation report using R. I will try to replicate the PV method used in Excel as the formula is quite straight-forward (not creating FV method here). The Price/Yield method in R, is expected to produce larger discrepancies. This is probably because the BondValuation package, although using the same Newton method, dives deeper into the bond’s cash flow characteristics. For example, different variants of ACT/365 day count convention can make a large difference in the yield. It is likely that your investment system’s algorithm are more closely designed this way.\nYou don’t have to write an entire program just to make comparisons if Excel does its job, although it helps to access data directly from database using SQL and make use of programs like R in which you can clean the data from before performing any analysis. Study what you are comparing against, what your tolerance level is and whether you want to monitor to ensure no unusual gaps.\nGiven the information in the top table table, we create a few new variables.\nBond holdings information you need to compute everything else\nNo\nName\nDescription\n1\nParValue\nFace or redemption value\n2\nPrincipal\nPurchased amount (clean price)\n3\nSettleDate\nSettlement date of purchase\n4\nMaturityDate\nMaturity date of bond\n6\nCouponRate\nAnnual coupon rate\nCreate new variables\nNo\nName\nDescription\nFormula\n1\nReportDate\nValuation Date\nUser input date\nFor PV method:\n\n\n\n2\nAmortDays\nNo. of days from SettleDate to ReportDate\nMaturityDate-SettleDate\n3\nDaysToMat\nNo. of days from ReportDate to MaturityDate\nMaturityDate-ReportDate\n3\nCouponDaily\nDaily accrued interest\nParValue*CouponRate/365\n4\nYieldDaily\nYield (daily rate)\nOptimisation method\n5\nBookValue1\nBook value as at ReportDate (method 1)\nPV of ash flow from SettleDate to MaturityDate\nFor Price Method:\n\n\n\n6\nBookYield\nYTM as at purchase date\nYTM\n7\nPriceRD\nPrice as at ReportDate, based on BookYield\nPrice\n8\nBookValue2\nBook value as at report date (method 2)\nPrice*ParValue\n9\nDiffBV\nCompare results of both book values\nBookValue2-BookValue1\n\nClick the button on the right to display the code.\n\n\nlibrary(dplyr)\nlibrary(BondValuation)\n\nReportDate <- as.Date('2009-09-30')\n\nAmortDays <- as.numeric(with(Holdings,as.Date(MaturityDate)-as.Date(SettleDate)))\nDaysToMat <- as.numeric(with(Holdings,as.Date(MaturityDate)-as.Date(ReportDate)))\nCouponDaily <- with(Holdings,ParValue*CouponRate/365)\n\n\n\n\nNext, we establish the book value amount using PV method. The steps are:\nfind the yield per day (r) given the par value (P), purchase amount (S), daily coupon amount (C) and number of days from settlement to maturity (n). We use the standard PV formula (see Deriving Financial Formulas using Geometric Series):\\(S =~ _C\\frac{1-(1+r)^{-n}}{r} + \\frac{P}{(1+r)^n}\\)\nTo avoid using the approximation formula, we use the optimisation technique where the absolute margin of error from the target number (in this case, S) is calculated for different r values. So we want to minimise the error to 0. We can use differentiation and weights to perform this (similar to back propagation in neural networks) but fortunately R comes with the optimize() function. This function calculates the r value where the gradient of the graph is 0.\nUse the result of r and re-apply to the PV formula above but using this time, the number of days from reporting date to maturity date, to give you the book value.\n\n\n\nyield_error <- function(r,n,P,S,C) abs((C*(1-(1/(1+r)^n))/r + (P/(1+r)^n))-S)\n\nYieldDaily <- vector(\"numeric\",20) # an empty vector is required for the following loop to populate to.\n\nfor(i in 1:20){\n  YieldDaily[i] = optimize(yield_error,\n                           c(0,0.01),\n                           P = Holdings$ParValue[i],\n                           S = Holdings$Principal[i],\n                           C = Holdings$ParValue[i]*Holdings$CouponRate[i]/365,\n                           n = AmortDays[i],\n                           tol = .Machine$double.xmin)[[1]]\n# double square brackets to hide header for each record since the output is a list. Not necessary here but just to take note.\n}\n\nBookValue1 <- CouponDaily*(1-(1/(1+YieldDaily)^DaysToMat))/YieldDaily + (Holdings$ParValue/(1+YieldDaily)^DaysToMat)\n\n\n\n\nThe second method requires the package “BondValuation” to be installed. We use the package’s Yield function to calculate the book yield. Instead of supplying the number of days, we input the actual dates and let the function do the maths.\nThe resulting yield is then used to compute the price (package’s Price function) and finally the book value as at report date.\n\n\nBookYield <- vector(\"numeric\",20)\n\nfor(i in 1:20){\n  BookYield[i] = BondVal.Yield(CP = Holdings$Principal[i]/Holdings$ParValue[i]*100,\n                             SETT = as.Date(Holdings$SettleDate[i]),\n                             Mat = as.Date(Holdings$MaturityDate[i]),\n                             CpY = 2,\n                             Coup = Holdings$CouponRate[i]*100,\n                             Em = as.Date('2000-01-01'), # arbitrary value, required field but not necessary for YTM calculation.\n                             DCC=10,\n                             Precision = .Machine$double.eps^0.75)[[4]] # cannot use xmin or lower as processing time will be too long. \n}\n\nPriceRD <- vector(\"numeric\",20)\n\nfor(i in 1:20){\n  PriceRD[i] = BondVal.Price(YtM = BookYield[i],\n                             SETT = ReportDate,\n                             Mat = as.Date(Holdings$MaturityDate[i]),\n                             CpY = 2,\n                             Coup = Holdings$CouponRate[i]*100,\n                             Em = as.Date('2000-01-01'),\n                             DCC = 10)[[1]]\n}\n\nBookValue2 <- PriceRD*Holdings$ParValue/100\nDiffBV <- BookValue2-BookValue1\n\n\n\n\nCreate a new data frame to add all the variables as columns.\n\n\namortisation <- Holdings %>%\n  mutate(ReportDate,\n         AmortDays,\n         DaysToMat,\n         CouponDaily,\n         YieldDaily=YieldDaily*100,\n         BookYield,\n         PriceRD,\n         BookValue1,\n         BookValue2,\n         DiffBV)%>%\n  select(!c(ReportDate,CouponRate,MaturityDate,SettleDate,PriceRD))\n\n\n\n\nDesign the table output using DT.\n\n\ndatatable(amortisation, rownames = FALSE, options = list(\n searching = FALSE,\n pageLength = 30,\n lengthMenu = c(10,20,30))) %>%\n  formatRound(c('ParValue', 'Principal'), 0) %>%\n  formatRound(c('BookValue1', 'BookValue2', 'DiffBV'),2) %>%\n  formatRound(c('CouponDaily', 'BookYield', 'YieldDaily'),4) %>%\n  formatRound('YieldDaily',6)\n\n\n\n{\"x\":{\"filter\":\"none\",\"data\":[[\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"O\",\"N\",\"P\",\"Q\",\"R\",\"S\",\"T\"],[5000000,50000000,20000000,5000000,25000000,25000000,40000000,10000000,50000000,30000000,5000000,15000000,10000000,30000000,50000000,30000000,15000000,20000000,12000000,15000000],[5026500,50010500,20016000,4995000,25330750,24862500,39260000,9815000,49942000,30060000,5140250,15421500,10261000,28008000,46285000,27666000,13824000,18414000,13236000,15210000],[1237,1307,1982,1980,1303,2015,1719,1719,7305,7299,7287,7287,7286,7252,7244,7234,7234,7230,6745,3824],[195,728,575,575,728,1244,1244,1244,6194,6194,6194,6194,6194,6452,6452,6452,6452,6452,5767,3712],[530,4906.84931506849,2058.08219178082,514.520547945205,2625.34246575343,2535.61643835616,4056.98630136986,1014.24657534247,6450.68493150685,3870.41095890411,645.068493150685,1935.20547945205,1290.13698630137,2878.35616438356,4797.2602739726,2878.35616438356,1439.17808219178,1918.90410958904,1590.24657534247,1799.17808219178],[0.010144078555699,0.00979657998542706,0.0102458087221478,0.0103462682850443,0.009422368911451,0.0104451638028964,0.0113269054727421,0.0113269054727421,0.0129259101854432,0.0128591253877254,0.0123181482502595,0.0123171272440528,0.0123579755339815,0.0109200829940192,0.0110866667833749,0.011162067493818,0.0111747865537455,0.0111944894816065,0.0110836414365427,0.011541675511791],[3.70209941625768,3.57896282369374,3.74027212867523,3.77723856899577,3.43924670485851,3.81992901199433,4.14263827449015,4.14263827449015,4.72091011100386,4.69633391176738,4.49742068253776,4.49704536165858,4.51206008964116,3.99170720377144,4.05297740983741,4.08069357171206,4.0853750511352,4.09261527551021,4.0425605965988,4.21497541618772],[5004401.33603032,50006013.8907041,20004980.8424223,4998441.0150832,25189785.6664651,24911724.820357,39450291.8791314,9862572.96978285,49947701.8303291,30054113.7222836,5126345.66262034,15379711.0371238,10235181.7870931,28158586.3053791,46561641.7108568,27837379.129355,13910309.8016503,18529787.9188466,13108728.5680132,15205075.3209713],[5004084.80059675,50002643.2078642,20003485.9288696,4998066.80255974,25188061.9165439,24911158.7822379,39452875.69464,9863218.92366,49945939.832227,30053059.6300135,5126115.82769827,15379021.238906,10234731.3818209,28156960.338117,46559232.2269509,27836087.1475486,13909666.1464443,18528962.9500587,13108150.1908038,15203087.828018],[-316.53543356806,-3370.68283993006,-1494.91355272382,-374.212523462251,-1723.74992115051,-566.038119155914,2583.8155085966,645.95387714915,-1761.998102054,-1054.09227010235,-229.834922070615,-689.79821780324,-450.405272221193,-1625.96726204082,-2409.48390588164,-1291.98180645704,-643.655206056312,-824.968787975609,-578.377209369093,-1987.49295334332]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th>Bond<\\/th>\\n      <th>ParValue<\\/th>\\n      <th>Principal<\\/th>\\n      <th>AmortDays<\\/th>\\n      <th>DaysToMat<\\/th>\\n      <th>CouponDaily<\\/th>\\n      <th>YieldDaily<\\/th>\\n      <th>BookYield<\\/th>\\n      <th>BookValue1<\\/th>\\n      <th>BookValue2<\\/th>\\n      <th>DiffBV<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"searching\":false,\"pageLength\":30,\"lengthMenu\":[10,20,30],\"columnDefs\":[{\"targets\":6,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 6, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":5,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 4, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":7,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 4, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":6,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 4, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":8,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":9,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":10,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":1,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 0, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":2,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 0, 3, \\\",\\\", \\\".\\\"); }\"},{\"className\":\"dt-right\",\"targets\":[1,2,3,4,5,6,7,8,9,10]}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[\"options.columnDefs.0.render\",\"options.columnDefs.1.render\",\"options.columnDefs.2.render\",\"options.columnDefs.3.render\",\"options.columnDefs.4.render\",\"options.columnDefs.5.render\",\"options.columnDefs.6.render\",\"options.columnDefs.7.render\",\"options.columnDefs.8.render\"],\"jsHooks\":[]}\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-02-04T01:38:16+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-06-30 Deriving Financial Formulas Using Geometric Sum/",
    "title": "Geometric Sum",
    "description": "Understanding how most time series formula is derived.",
    "author": [
      {
        "name": "Chen Xihui",
        "url": {}
      }
    ],
    "date": "2020-06-30",
    "categories": [
      "Financial Maths"
    ],
    "contents": "\nSum of a Geometric Series\nExcel’s built-in functions are useful only if you depend entirely on spreadsheets to generate financial numbers. If you already understand the common finance terms and their meanings, but want to know more about the mathematics behind it (perhaps you want write a simple financial program), it is important to realise that most calculations involving loans and bonds comes from the time value of moeny formula. Take a look at some of the financial functions available in Excel - IRR, FV, NPV, PMT, PRICE and YIELD. They are all derived from the same formula; the only difference is the input you provide as function variables required under different purpose and assumptions. It is also worth noting that where lengthy time series make computation more tedious, one of the most useful formula to apply is the geometric series formula. Most of you will recall learning it in algebra class but never had the chance to use it in real life. Blame it on computers, maybe, but we have come to be more familiar with the name of mathematical functions than the actual formula itself.\nA geometric progression is a sequence obtained by multiplying the preceding term by a constant, called a common ratio. The sequence [3, 6, 12, 24, 48, 96] follows a geometric progression \\(a, ar, ar^2, ar^3, ar^4\\). The first term , a, is 3 and the common ratio, r is 2. The number of terms, n, in the series is 5.\nThe sum of the first n terms of a geometric progression is given by:\n\\[S_n=a~+~ar~+~ar^2~+~...~+ ar^{n-1}\\] Notice the similarity with formulas such as the time value of multiple cash flows.\n\\(Present Value=\\frac{C_1}{(1+r)^1}+\\frac{C_2}{(1+r)^2}+\\frac{C_3}{(1+r)^3}+...\\frac{C_n}{(1+r)^n}\\)\nCalculation using the expanded form can be tedious When n is large. Fortunately, we can use a simple formula.\n\\(S_n=a+ar+ar^2+ar^3+...+ar^{n-3}+ar^{n-2}+ar^{n-1}\\)\n\\(S_n=a+r(a+ar+ar^2+...+ar^{n-3}+ar^{n-2})\\)\n\\(S_n=a+r(S_n-ar^{n-1})\\)\n\\(S_n=a+rS_n-ar^n\\)\n\\(S_n-rS_n=a-ar^n\\)\n\\(S_n(1-r)=a(1-r^n)\\)\n\\[S_n=\\frac{a(1-r^n)}{1-r}\\]\nUsing this formula, we can find the present value by substituting:\n\\(S_n = PV\\), \\(a=\\frac{C}{1+r}\\), \\(r=\\frac{1}{1+r}\\), \\(n=n\\)\nand we get:\n\ndiv.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}\n\n\\[PV=C~\\frac{1-(1+r)^{-n}}{r}\\]\n\nPeriodic Payment Formula\nBack to the loan example shown in Section 1.1. How do you manually calculate the monthly payment? Monthly Payment Amount \\[A = \\frac{Pr(1+r)^n}{(1+r)^n-1}\\]\n      where\n             A = Periodic Payment Amount\n             P = Present Value of Loan (Initial Loan Amount)\n             r = Interest rate for each period\n             n = Number of periods\nFrom the loan example:\nP = $200,000\nr = 0.005 (6.0% p.a. divided by 12)\nn = 24 (number of periods or months up to maturity)\n\\(A = \\frac{200,000*0.005(1+0.005)^{24}}{(1+0.005)^{24}-1} = 8,864.12\\)\nDeriving the formula\nForget about the above formula for a moment. With only information on p, r and n, you can easily calculate the first month’s interest amount. That’s probably as far as you get with the schedule without performing any trial and error. What method might you think of to determine a series of fixed amount that spreads out the principal repayment nicely across two years, pay interest according to the monthly balance and be left owing nothing at the end?\nIt is quite obvious to most that the present values of all monthly payments received in equal amounts must add up to the initial loan principal. This is translated into the present value formula:\n\\[P=\\frac{A}{(1+r)}+\\frac{A}{(1+r)^2}+\\frac{A}{(1+r)^3}+\\frac{A}{(1+r)^4}+...\\frac{A}{(1+r)^n}\\]\n        where\n               P = Present Value of all future payments\n               A = Constant Payment Amount\n               r = Periodic interest\n               n = Number of periods\nIn other words, we want to achieve a series of numbers like Column “O” of the payment schedule, in which the summation of all the present value interest and principal payments compensates for the initial loan principal. Since the only known variables at this point are P, r and n, to find A, we need to simplify and re-arrange the formula.\n\nPayment Schedule with Present Values\n\n\n",
    "preview": {},
    "last_modified": "2021-02-04T01:15:12+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-06-30 How Accurate is Excels Yield Function/",
    "title": "How Accurate is Excel's YIELD Function",
    "description": "\"Reverse-engineering\" and testing the accuracy of Excel's Yield function.",
    "author": [
      {
        "name": "Chen Xihui",
        "url": {}
      }
    ],
    "date": "2020-06-30",
    "categories": [
      "Bonds"
    ],
    "contents": "\nThe YIELD function is trusted by fixed income managers and has become the go-to source for reliable yield calculation. There are many ways to calculate yield based on the present value formula. The eventual result really depends on how much detail you put into the formula.\nI will not explain in detail how to calculate yield from start to finish, but show you some examples that compare the yields produced by Excel and R BondValuation. Contact me if you have any comments or want to learn how to calculate and I can send you the spreadsheet. These two adopt the same generally accepted formula which you can find in the Microsoft Excel Help File (see below). Both have high levels of precision and iterations. This similarity is the reason why R BondValuation is appropriate for doing this comparison. So what cause the discrepancies?\nBefore I start, I would like to conclude that if you are a trader or analyst who do not look past 3 decimal places, then from that perspective, Excel is very reliable. However, if you are just curious or have always wondered whether your system vendors are telling the truth, then hopefully this will help you gain a better understanding. I’m not saying what algorithms other systems use, or what the “true” yield is but rather this is about Excel’s method of computation.\n\nExcel Yield Function\n\nSource: Excel Help File\nUnless the settle date falls within the last coupon period before maturity, Excel uses this Price formula to run iterations to generate the yield. What the formula says is:\nIf the settlement date is on a coupon payment date, the n-th period follows the number of coupon payments remaining until maturity. For example, if you buy a bond exactly 2 years from maturity, then there are four payments to look forward to if it pays semi-annually. For each coupon, discount it using t=1,2,3 and 4.\nIf the settlement date is between two coupon dates, then you need to find the proportion of days between settle date and next coupon date to total number of days in the that period. That fractional amount will be the added to each coupon period following the next coupon date. Because the date is within the accrual period, the accrued interest paid must be deducted from the sum of the present value.\nNow, if you notice, the formula contains this coupon payment calculation:\n\\(100* \\frac{rate}{frequency}\\)\nthis is where the giveaway is as to why differences occur. This is a generic formula to derive the periodic coupon amount. Because of this formula, the day count convention, especially ACT/365, will affect the way coupon days, amount and period t are calculated. These are shown in the examples below.\n\nExample 1\nSettle date = coupon date (no accruals)\n\nThe bond yield is calculated using both ACT/365 and ACT/ACT day count convention (DCC). Using these yield, I create payment schedules to test the accuracy of yield and PV based on cash flows from different DCCs.\n\nNotice that for ACT/ACT, Excel and R have the same yield (equal digits up to 10 d.p. gives the same PV). However, you may be wondering why Excel’s ACT/365 is the same as ACT/ACT. This is because the number of days for each coupon period is 182.5, which means Excel does not do date-specific day calculation. Rather, it takes the 365 and divide by 2, resulting in equal amounts, mirroring the ACT/ACT cash flow. R BondValuation does take into account date-specific range and hence able to calculate more precisely the correct amount to discount for each period.\n\nExample 2\nSettle date falls in between 2 coupon periods\n\n\nIn this scenario, again, Excel uses 182.5 as the days in the period for ACT/365 throughout and the yield is very close to the ACT/ACT yield.\n\nConclusion\nExcel does not calculate the exact number of days within a coupon period for ACT/365. (Note also, it is not ACT/365L which does not take into account leap years). If you are very particular about this, Excel’s YIELD function is not going to give you the most accurate numbers you want. The discrepancies may be larger if your bonds are long term or have irregular payment dates, modified following/preceding rules, or payment days are not equal to maturity day, etc. If your portfolio values are large, you may see big differences in your amortised book value or even other values that rely on yield (duration, etc.). This is not to say that the BondValuation package does everything accurately. It has some limitations, one of which is the coupon dates which do not get adjust for non-business day rules. Due to numerous characteristics of bonds worldwide, it is probably difficult to find a system that fully covers all types of bonds and conventions (see also other R Financial Packages such as RQuantlib). If you can’t find one that can closely replicate the actual cash flow of the bond you want to analyse, look no further than Excel itself. All you have to do is input the correct date, amount and time period, and run goal seek. The results are accurate but you will need to spend some time to setup the schedule manually. Not a good idea if you have many bonds in your portfolio.\nLastly, you saw in my post about constant yield amortisation and how the daily yield (using the rate function) is derived. Do not ever use daily cash flow to find a bond’s yield. That method assumes that you are re-investing daily accruals everyday, although the actual payment received is at least monthly for bonds. However, it is somewhat acceptable for amortisation purpose as it smooths out the curve and meets its target to amortise fully and uniformly the premium/discount amount.\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-02-04T01:23:00+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-06-30 Loan Amortisation/",
    "title": "Loan Amortisation",
    "description": "Understanding the loan amortisation schedule helps you to understand bond amortisation.",
    "author": [
      {
        "name": "Chen Xihui",
        "url": {}
      }
    ],
    "date": "2020-06-30",
    "categories": [
      "Bonds"
    ],
    "contents": "\n\nAn amortisation schedule shows the repayment details of a loan which is to be paid off through a series of equal and regular payments. A typical schedule consists of principal balance, payment amount and interest/principal breakdown for each period until maturity.\nTo create an amortisation schedule, you need the loan amount, annual rate of interest, the number of payment periods that it takes to pay off the loan and the periodic payment amount.\n\nCreate a Schedule in Excel\nA schedule can be built using two methods. The first method first determines the fixed periodic amount using the PMT function. Then, starting with the original loan amount, interest rate and periodic amount, the values of other variables in the schedule are built using simple arithmetic formulas. I prefer this method because it is more comprehensible and allows for flexibility in varying payments and rates at any time during the life of the loan. For example, if you plan to use the schedule to track your loan balances accurately, modifying it to account for “non-regular” transactions1 is a lot easier since any adjustments made to that period flow to the remaining periods.\n(1generally, add a new column if miscellaneous transactions fall on regular payment dates, and split the period to re-calculate interest if transactions fall outside regular due dates.)\nThe second method uses built-in financial functions provided by Excel. These functions can be used to compute each variable independently for any period, allowing you to design a single-period calculator or a multi-period schedule (full or partial).\nExcel Function\nCalculates\nPMT\nfixed periodic payment\nFV\nprincipal balance at any specific period\nIPMT\ninterest portion of the fixed payment at any specific period\nPPMT\nprincipal portion of the fixed payment at any specific period\nCUMIPMT\ncumulative interest payment between a start period and an end period\nCUMPRINC\ncumulative principal payment between a start period and an end period\n\nCreate a Schedule in R\nThe objective is to create a data frame that contains the same information as the one created using a spreadsheet. There are several methods to create a simple loan amortisation schedule in R.\nThe most common method is using the loop function that calculates and populate all variables one row at a time until the maximum period has been reached. The logic is similar to creating a schedule in Excel where one variable references another variable in the same time period or row, and next row is dependent on the results of the preceding row. Then the iteration is repeated until the last row.\nThe second method attempts to calculate, as much as possible, each variable independently of other variables. For example, given the inputs in the function arguments, you can calculate using a single formula what the loan balance is on a specific period, without needing to know what the prior period balance is or the principal portion of the payment. The second method is probably not ideal, and far less flexible than the first method. However, it works well if you have hundreds or thousands of loan positions and you do not want to create a full schedule for each of them. The first method works well if you want to add more variables like fees, prepayment or change in interest rates. But these are just simple models for you to explore if you are building a simple schedule (read up about vectorisation vs loop).\n\nMethod 1\nloan = Initial Loan Amount\nmonths = Total number of months\nrate = Interest rate per year\n\nClick the button on the right to display the code.\n\n\nschedule1 <-  function(loan, months, rate) {\n  r <- rate/12\n  payment <<- loan*r*(1+r)^(months)/((1+r)^(months)-1)\n  \n  Begin_Balance = Interest = Total = Payment = Principal = Outstanding = vector(\"numeric\", months)\n  loan_outstanding = loan\n  \n  for (i in 1:months) {\n    loan_b_balance = loan_outstanding\n    loan_interest = loan_outstanding * r\n    loan_total = loan_b_balance + loan_interest\n    loan_payment = payment\n    loan_principal = loan_payment - loan_interest\n    loan_outstanding = loan_outstanding - loan_principal\n    \n    Begin_Balance[i] = loan_b_balance\n    Interest[i]  = loan_interest\n    Total[i] = loan_total\n    Payment[i] = loan_payment\n    Principal[i] = loan_principal\n    Outstanding[i] = loan_outstanding\n    \n    schedule1_df <<- data.frame(Months = 1:months, Begin_Balance, Interest, Total, Payment,\n                                 Principal, Outstanding)\n  }\n}\n\nschedule1(200000,24,0.06)\n\ndatatable(schedule1_df, rownames = FALSE, options = list(\n  searching = FALSE,\n  pageLength = 30,\n  lengthMenu = c(10,20,30)\n  \n)) %>%\n  formatRound(c('Begin_Balance', 'Interest', 'Total', 'Payment', 'Principal','Outstanding'), 2)\n\n\n\n{\"x\":{\"filter\":\"none\",\"data\":[[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],[200000,192135.877949448,184232.435288644,176289.475414536,168306.800741057,160284.212694211,152221.51170713,144118.497215114,135974.967650638,127790.72043834,119565.55198998,111299.257699378,102991.631937324,94642.4680464588,86251.5583361395,77818.6940772687,69343.6654971034,60826.2617740374,52266.271032356,43663.4803369663,35017.6756880995,26328.6420159885,17596.1631755169,8820.02194084288],[1000,960.679389747242,921.162176443221,881.447377072679,841.534003705285,801.421063471053,761.107558535651,720.592486075571,679.874838253191,638.953602191699,597.8277599499,556.496288496892,514.958159686619,473.212340232294,431.257791680698,389.093470386343,346.718327485517,304.131308870187,261.33135516178,218.317401684831,175.088378440498,131.643210079942,87.9808158775843,44.1001097042144],[201000,193096.557339196,185153.597465087,177170.922791608,169148.334744762,161085.633757682,152982.619265666,144839.08970119,136654.842488891,128429.674040532,120163.37974993,111855.753987875,103506.59009701,95115.6803866911,86682.8161278202,78207.787547655,69690.383824589,61130.3930829076,52527.6023875178,43881.7977386511,35192.76406654,26460.2852260684,17684.1439913944,8864.1220505471],[8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156],[7864.12205055156,7903.44266080431,7942.95987410834,7982.67467347888,8022.58804684627,8062.7009870805,8103.01449201591,8143.52956447599,8184.24721229837,8225.16844835986,8266.29429060166,8307.62576205467,8349.16389086494,8390.90971031926,8432.86425887086,8475.02858016521,8517.40372306604,8559.99074168137,8602.79069538978,8645.80464886673,8689.03367211106,8732.47884047161,8776.14123467397,8820.02194084734],[192135.877949448,184232.435288644,176289.475414536,168306.800741057,160284.212694211,152221.51170713,144118.497215114,135974.967650638,127790.72043834,119565.55198998,111299.257699378,102991.631937324,94642.4680464588,86251.5583361395,77818.6940772687,69343.6654971034,60826.2617740374,52266.271032356,43663.4803369663,35017.6756880995,26328.6420159885,17596.1631755169,8820.02194084288,-4.46016201749444e-09]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th>Months<\\/th>\\n      <th>Begin_Balance<\\/th>\\n      <th>Interest<\\/th>\\n      <th>Total<\\/th>\\n      <th>Payment<\\/th>\\n      <th>Principal<\\/th>\\n      <th>Outstanding<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"searching\":false,\"pageLength\":30,\"lengthMenu\":[10,20,30],\"columnDefs\":[{\"targets\":1,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":2,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":3,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":4,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":5,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":6,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"className\":\"dt-right\",\"targets\":[0,1,2,3,4,5,6]}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[\"options.columnDefs.0.render\",\"options.columnDefs.1.render\",\"options.columnDefs.2.render\",\"options.columnDefs.3.render\",\"options.columnDefs.4.render\",\"options.columnDefs.5.render\"],\"jsHooks\":[]}\n\n\n# This is alternative code for below code. Its; the same, but less neat\nloan_int = loan_prin = loan_outstanding = vector(\"numeric\", 24)\n\n\nfor (i in 1:24) {\n  loan_outstanding[i] = 200000\n  loan_int[i] = {if(i==1) loan_outstanding[i] * 0.005\n    else loan_outstanding[i-1] * 0.005}\n  loan_prin[i] = 8864.12 - loan_int[i]\n  loan_outstanding[i] = {if(i==1) loan_outstanding[i] - loan_prin[i]\n    else loan_outstanding[i-1] - loan_prin[i]}\n\n  #loan_int[i] = loan_int\n  #loan_prin[i] = loan_prin\n  #loan_outstanding[i] = loan_outstanding\n  \n}\n\nloan_int\nloan_prin\nloan_outstanding\n\n\n\n\nMethod 2\nAs before, the following information and formulas need to be established in R, we will put these together within a function with four parameters: function (Loan, Rate, Years, Freq)\nwhere\nLoan = Initial Loan Amount\nRate = Interest Rate per Year\nYears = Loan Tenure in Years\nFreq = Payment Frequency per Year\n\nNo.\nAssigned Name\nDescription\nFormula\n1\nn\nTotal number of periods\nYears * Freq\n2\nr\nInterest rate per period\nRate / Freq\n3\npmt\nPeriodic Payment\nPerdiodic payment formula\n5\nppmt\nPrincipal portion of payment\nPeriod 1 increases at a rate of (1+r)\n6\nppmtc\nCumulative principal\nCumulative sum of ppmt\n7\nipmt\nInterest portion of payment\nPeriod 1 Interest less incremental value of ppmt from period 1\n8\npbal\nPrincipal balance of loan\nFuture value of Loan and pmt\n\nClick the button on the right to display the code.\n\n\n# Create a function to calculate payment variables\n\nschedule2 <- function(Loan, Rate, Years, Freq){\n  n <- Years*Freq\n  r <- Rate/Freq\n  period <<- 1:n\n  pmt <<- Loan*r*(1+r)^(n)/((1+r)^(n)-1)\n  ppmt <<- (pmt-(Loan*r))*(1+r)^(0:(n-1))\n  ppmtc <<- cumsum(ppmt)\n  ipmt <<- (Loan * r) - (pmt-(Loan*r))*((1+r)^(0:(n-1))-1)\n  pbal <<- Loan*(1+r)^(1:n) - pmt/r*((1+r)^(1:n)-1)\n}\n\nschedule2(200000, 0.06, 2, 12)\nloan_schedule2 <- data.frame( Month = period,\n                             Payment = pmt,\n                             Interest = ipmt,\n                             Principal = ppmt,\n                             Cumulative_Principal = ppmtc,\n                             Balance = pbal)\n\ndatatable(loan_schedule2, rownames = FALSE, options = list(\n  searching = FALSE,\n  pageLength = 30,\n  lengthMenu = c(10,20,30)\n  \n)) %>%\n  formatRound(c('Payment', 'Interest', 'Principal','Cumulative_Principal', 'Balance'), 2)\n\n\n\n{\"x\":{\"filter\":\"none\",\"data\":[[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24],[8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156,8864.12205055156],[1000,960.679389747243,921.162176443223,881.447377072682,841.534003705288,801.421063471058,761.107558535655,720.592486075577,679.874838253197,638.953602191708,597.827759949908,556.496288496901,514.958159686629,473.212340232305,431.25779168071,389.093470386356,346.718327485531,304.131308870203,261.331355161797,218.317401684849,175.088378440517,131.643210079962,87.9808158776053,44.1001097042356],[7864.12205055156,7903.44266080431,7942.95987410833,7982.67467347888,8022.58804684627,8062.7009870805,8103.0144920159,8143.52956447598,8184.24721229836,8225.16844835985,8266.29429060165,8307.62576205466,8349.16389086493,8390.90971031925,8432.86425887085,8475.0285801652,8517.40372306603,8559.99074168135,8602.79069538976,8645.80464886671,8689.03367211104,8732.4788404716,8776.14123467395,8820.02194084732],[7864.12205055156,15767.5647113559,23710.5245854642,31693.1992589431,39715.7873057894,47778.4882928698,55881.5027848858,64025.0323493617,72209.2795616601,80434.4480100199,88700.7423006216,97008.3680626763,105357.531953541,113748.44166386,122181.305922731,130656.334502896,139173.738225963,147733.728967644,156336.519663034,164982.3243119,173671.357984011,182403.836824483,191179.978059157,200000.000000004],[192135.877949449,184232.435288645,176289.475414536,168306.800741058,160284.212694212,152221.511707131,144118.497215115,135974.967650639,127790.720438342,119565.551989982,111299.25769938,102991.631937326,94642.4680464609,86251.558336142,77818.6940772712,69343.6654971062,60826.2617740405,52266.2710323594,43663.4803369698,35017.6756881033,26328.6420159923,17596.163175521,8820.02194084713,2.91038304567337e-11]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th>Month<\\/th>\\n      <th>Payment<\\/th>\\n      <th>Interest<\\/th>\\n      <th>Principal<\\/th>\\n      <th>Cumulative_Principal<\\/th>\\n      <th>Balance<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"searching\":false,\"pageLength\":30,\"lengthMenu\":[10,20,30],\"columnDefs\":[{\"targets\":1,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":2,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":3,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":4,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"targets\":5,\"render\":\"function(data, type, row, meta) { return DTWidget.formatRound(data, 2, 3, \\\",\\\", \\\".\\\"); }\"},{\"className\":\"dt-right\",\"targets\":[0,1,2,3,4,5]}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[\"options.columnDefs.0.render\",\"options.columnDefs.1.render\",\"options.columnDefs.2.render\",\"options.columnDefs.3.render\",\"options.columnDefs.4.render\"],\"jsHooks\":[]}\n# Question: why does it stop at 24 rows?\n# Answer: As long as any one of the variables produces n number of rows.\n# The others will follow. In this case, 0:(n-1) in pmt_P. Without this, you would want\n# to add a new assignement that has a sequence from 1:n\n# Works only if you put everything within a function.\n\n\n\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-02-04T01:30:05+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-06-05 Get Flask Up and Running with Anaconda Navigator/",
    "title": "Get Flask Up and Running with Anaconda Navigator",
    "description": "Step-by-step guide to install Flask.",
    "author": [
      {
        "name": "Chen Xihui",
        "url": {}
      }
    ],
    "date": "2020-06-05",
    "categories": [
      "Python"
    ],
    "contents": "\nExecuting commands from your Terminal or Command Prompt is almost unavoidable in Python. You will find that many course instructors use them to perform even simple tasks like opening a file. Beginners following step-by-step may find it difficult to make sense of what is going on in the command line environment.\nIf you are eager to get your first Flask project started, but find the initial setup confusing, here are the steps to follow to get you started painlessly.\nOne-time setup\nCreate a new environment for your project\nInstall flask in the new environment\nInstall Spyder in the new environment (optional)\n\nRun your application\nRun your .py file\n\nYou are done with flask for the day\nStop the server\n\nThe overall setup is like any other flask installation, but with Anaconda Navigator, the process is simplified because you don’t have to worry about the command line.\nI assume you have installed Anaconda Navigator, if not, here is the link. Your installation includes the flask package, but only in the base environment.\nNote: I am using MacOS 10.15. My Anaconda Navigator version is 1.9.12 and Python version is 3.7. The steps below applies to both Mac OS and Windows.\nOne-time Setup\n1. Create a new environment for your project\nOpen the Anaconda Navigator app\nOn the left pane, click Environments\nAt the bottom of the page, click Create\nEnter a new environment name eg. virenv\nMake sure the location and Python version are displayed. If not, re-start the app and do not launch any other applications within the app yet\nTake note of the default Location because this is where you will be saving your files later.\nClick Create and wait for the setup to complete.\n2. Install flask in the new environment\nThe new environment will automatically pre-load about a dozen packages but does not include flask\nOn the right panel of the Environments page, look for the drop down list at the top where the defult value is “installed”. Select “All”.\nSearch “flask”\nSelect flask by clicking on the checkbox. There are other flask extensions but you can ignore those for now.\nClick apply\nAnaconda will install flask and its dependecies.\n3. Install Spyder in the new environment\nOn the Home page of the Navigator, select your new environment name in the Applications on drop down list.\nClick on the Install button in the Spyder box(You can install your favourite IDE if you like. My default IDE is IDLE but it seems to have an issue with Ctrl-C to stop the server.)\n4. Create a .py file and folders\nLaunch Spyder\nWrite a basic flask code like the one below and save it in the virenv (or whatever name you had chosen to call it) folder. In this example, let’s call it main.py.\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")  \ndef home():  \nreturn \"Hello, World!\"\n\nif __name__ == \"__main__\":  \napp.run(debug=True)\nUsing your Finder or Windows Explorer, create two blank folders inside the virenv folder: static and templates (you don’t have to at this point but you are going to end up creating them anyway)\nThat’s all for the one-time setup.\nRun your application (main.py)\nLaunch Spyder from the Home page of Anaconda Navigator. Make sure that you select the correct environment from the Applications On drop-down list (for Windows user, you can launch Spyder directly but choose the one that shows your environment name).\nOpen your main.py file located in ../opt/anaconda3/envs/virenv (if you are using Mac)\nClick the Run button.\nYour can now start working on your application. No export or flask run command line required.\nTest if it works by typing “localhost:5000” in your browser. If you make changes to the file, just save it and run the file again from Spyder. Make sure to check the console that the reload is successful.\nYou are done with flask for the day\nMove your cursor to the Spyder console and type Ctrl-C to quit. If you are using Windows, right click on the comsole and select Quit.\nSo, that’s it. I hope this was easy enough for you to follow and you managed to setup your environment without any problems.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-02-03T23:39:08+08:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-06-03 Creating MySQL DB Instance on AWS RDS/",
    "title": "Creating a MySQL DB Instance on AWS RDS",
    "description": "A short description on setting up MySQL on AWS.",
    "author": [
      {
        "name": "Chen Xihui",
        "url": {}
      }
    ],
    "date": "2020-06-03",
    "categories": [
      "Database"
    ],
    "contents": "\nAmazon Relational Database Service’s user guide Creating a MySQL DB Instance and Connecting to a Database on a MySQL DB Instance provides a very clear instruction for first time users.\nThe setup is simple when configured using the Easy Create. The only issue I encountered after the database had been successfully created was that the MySQL Workbench installed on my machine could not connect to the new database. It was resolved after making changes to the inbound rules (in security group rules) to Type = All Traffic and Source = My IP. I’m not sure if this opens up any security risk but for now, since access is restricted to my IP only and the database is a test database, it should be fine.\nNext step is to install MySQL client on your local machine to manage the databases.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-02-03T21:03:28+08:00",
    "input_file": {}
  }
]
